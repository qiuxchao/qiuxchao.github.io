---
title: 排序和查找
date: 2020-02-05 08:08:08
# top: 近期更新
categories: 算法
tags: 算法
---

# 排序和查找

## 排序算法

> 排序算法没有优劣之分，在不同的场景中，不同的排序算法执行效率不同。

1. **冒泡排序 Bubble Sort**

一次冒泡排序，可以将某个区域序列的最大值排序到该区域的最后一位，具体的方式是：

1) 将第1位和第2位比较，如果前者比后者大则交换
2) 将第2位和第3位比较，如果前者比后者大则交换
3) 依次类推，直到比较到该区域的最后两位
4) 重复上述过程，直到序列排序完成

> 冒泡排序效率一般，在各种情况下不会太好，也不至于太差
> 如果数组本身是比较有序的，冒泡排序还是不错的

2. **插入排序 Insertion Sort**

将序列分为两个部分，一部分是有序的，一部分是无序的，现在要做的是，就是不断的从无序的部分取出数据，加入到有序的部分，直到整个排序完成

例如：序列[5, 7, 2, 3, 6]

1) 分为有序的序列和无序的序列  (5) (7 2 3 6)
2) 不断的扩充有序序列  (5  7) (2  3  6)
3) 不断的扩充有序序列  (2  5  7) (3  6)
4) 不断的扩充有序序列  (2  3  5  7) (6)
5) 不断的扩充有序序列  (2  3  5  6  7)
6) 排序完成

> 插入排序在小规模的数组中效率很高，如果数组本身是比较有序的，则效率会进一步提升
> V8引擎在数组比较小的时候会使用插入排序

3. **快速排序 Quick Sort**

选择一个数（比如序列的最后一位）作为基准数，将整个序列排序成两部分，一部分比该数小，另一部分比该数大，基准数在中间，然后对剩余的序列做同样的事情，直到排序完成

例如：序列[5, 7, 2, 3, 6, 4]

1) 选择4作为基准数，排序成为：(3, 2) 4 (7, 6, 5)
2) 对于3,2， 继续使用该方式排序，得到：  (2, 3) 4 (7,6,5)
3) 对于7,6,5，继续使用该方式排序，得到： (2, 3) 4  (5,6,7)
4) 排序完成

> 当数组比较大并且比较混乱的时候，使用快速排序效率很高
> V8引擎在数组较大时会自动使用快速排序

## 查询算法

1. **顺序查找 Inorder Search**

即普通的遍历，属于算法的穷举法，没啥好解释的

2. **二分查找 Binary Search**

如果一个序列是一个排序好的序列，则使用二分查找可以极大的缩短查找时间

具体的做法是：

查找该序列中间未知的数据
   1) 相等，找到
   2) 要找的数据较大，则对后续部分的数据做同样的步骤
   3) 要找的数据较小，则对前面部分的数据做同样的步骤

3. **插值查找 Interpolation Search**

插值查找是对二分查找的进一步改进

如果序列不仅是一个排序好的序列，而且序列的步长大致相同，使用插值查找会更快的找到目标。

插值查找基于如下假设：下标之间的距离比和数据之间的距离比大致相同，即：

```
(目标下标-最小下标) / (最大下标 - 最小下标) ≈ (目标值 - 最小值) / (最大值 - 最小值)
```

因此可以算出大致的下标落点：

```
目标下标 ≈ (目标值 - 最小值) / (最大值 - 最小值) * (最大下标 - 最小下标) + 最小下标
```

这样就可以计算出大致的下标落点，后续的比较和二分查找一样。

